# Kubernetes 的概述
Kubernetes，又称为 k8s（首字母为 k、首字母与尾字母之间有 8 个字符、尾字母为 s，所以简称 k8s）或者简称为 "kube" ，是一种可自动实施 Linux 容器操作的开源平台。它可以帮助用户省去应用容器化过程的许多手动部署和扩展操作。也就是说，您可以将运行 Linux 容器的多组主机聚集在一起，由 Kubernetes 帮助您轻松高效地管理这些集群。而且，这些集群可跨公共云、私有云或混合云部署主机。因此，对于要求快速扩展的云原生应用而言，Kubernetes 是理想的托管平台。

Kubernetes 最初由 Google 的工程师开发和设计。Google 是最早研发 Linux 容器技术的企业之一（组建了cgrous)，曾公开分享介绍[Google 如何将一切都运行于容器之中（这是 Google 云服务背后的技术）。Google 每周会启用超过 20 亿个容器——全都由内部平台 Borg 支撑。Borg 是 Kubernetes 的前身，多年来开发 Borg 的经验教训成了影响 Kubernetes 中许多技术的主要因素。

趣事：Kubernetes 徽标的七个轮辐代表着项目最初的名称"九之七项目"(Project Seven of Nine)。

Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。

**Kubernetes** 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。


## 时光回溯

让我们回顾一下为什么 Kubernetes 如此有用。

![部署演进](https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg)

**传统部署时代：**

早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。

**虚拟化部署时代：**

作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。

虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。

每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。

**容器部署时代：**

容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。

容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：

- 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。
- 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。
- 关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。
- 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
- 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。
- 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。
- 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
- 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。
- 资源隔离：可预测的应用程序性能。
- 资源利用：高效率和高密度。

## Docker 的管理痛点

如果想要将 Docker 应用于庞大的业务实现，是存在困难的**编排**、**管理**和**调度**问题。于是，我们迫切需要一套管理系统，对 Docker 及容器进行更高级更灵活的管理。

Kubernetes 应运而生！Kubernetes，名词源于希腊语，意为「舵手」或「飞行员」。Google 在 2014 年开源了 Kubernetes 项目，建立在 Google 在大规模运行生产工作负载方面拥有十几年的经验的基础上，结合了社区中最好的想法和实践。


## 为什么需要 Kubernetes，它能做什么?

K8s 是一个可移植的、可扩展的开源平台，用于**管理容器化的工作负载和服务，可促进声明式配置和自动化**。K8s 拥有一个庞大且快速增长的生态系统。K8s 的服务、支持和工具广泛可用。

通过 K8s 我们可以：

1.快速部署应用

2.快速扩展应用

3.无缝对接新的应用功能

4.节省资源，优化硬件资源的使用

K8s 有如下特点:

1.可移植: 支持公有云，私有云，混合云，多重云 multi-cloud

2.可扩展: 模块化，插件化，可挂载，可组合

3.自动化: 自动部署，自动重启，自动复制，自动伸缩/扩展

## 云架构 & 云原生

1.云和 K8s 是什么关系

云就是使用容器构建的一套服务集群网络，云由很多的大量容器构成。K8s 就是用来管理云中的容器。

2.常见几类云架构

- On-Premises (本地部署)
- iaas（基础设施即服务）

- - 用户：租用（购买|分配权限）云主机，用户不需要考虑网络，DNS，硬件环境方面的问题。
  - 运营商：提供网络，存储，DNS，这样服务就叫做基础设施服务

- paas（平台即服务）

- - mysql/es/mq/...

- saas（软件即服务）

- - 钉钉
  - 财务管理

- serverless

- - 无服务，不需要服务器。站在用户的角度考虑问题，用户只需要使用云服务器即可，在云服务器所在的基础环境，软件环境都不需要用户关心。

3.云原生
为了让应用程序（项目，服务软件）都运行在云上的解决方案，这样的方案叫做**云原生**。

云原生有如下特点：

- 容器化，所有服务都必须部署在容器中
- 微服务，Web 服务架构式服务架构
- CI/CD
- DevOps

容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？

这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。

Kubernetes 为你提供：

- **服务发现和负载均衡**

  Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。

- **存储编排**

  Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。

- **自动部署和回滚**

  你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。

- **自动完成装箱计算**

  Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。

- **自我修复**

  Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。

- **密钥与配置管理**

  Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。

## Kubernetes 不是什么

Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。

Kubernetes：

- 不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。
- 不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。
- 不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行。

- 不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。
- 不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。
- 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。
- 此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。

## Kubernetes相关术语

和其它技术一样，Kubernetes 也会采用一些专用的词汇，这可能会对初学者理解和掌握这项技术造成一定的障碍。为了帮助您了解 Kubernetes，我们在下面来解释一些常用术语。

**主机（Master）：** 用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。

**节点（Node）：**负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。

**容器集（Pod）：**被部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。

**复制控制器（Replication controller）：**用于控制应在集群某处运行的完全相同的容器集副本数量。

**服务（Service）：**将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。

**Kubelet：**运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。

**kubectl：** Kubernetes 的命令行配置工具。

## Docker运行状态
Docker技术仍然执行它原本的工作。当 kubernetes 将容器集调度到一个节点上时，该节点上的 kubelet 会发送指令让 docker 启动指定的容器。kubelet 随后会不断从 docker 收集这些容器的状态，并将这些信息汇集至主机。Docker 将容器拉至该节点，并按照常规启动和停止这些容器。不同在于，自动化系统要求 docker 在所有节点上对所有容器执行这些操作，而非要求管理员手动操作。


## K8s 架构原理

1.K8s 架构

概括来说 K8s 架构就是一个 Master 对应一群 Node 节点。

下面我们来逐一介绍 K8s 架构图中的 Master 和 Node。

2.Master 节点结构如下：

- apiserver 即 K8s 网关，所有的指令请求都必须要经过 apiserver；
- scheduler 调度器，使用调度算法，把请求资源调度到某一个 node 节点；
- controller 控制器，维护 K8s 资源对象；
- etcd 存储资源对象；

3.Node节点

- kubelet 在每一个 node 节点都存在一份，在 node 节点上的资源操作指令由 kubelet 来执行；
- kube-proxy 代理服务，处理服务间负载均衡；
- pod 是 k8s 管理的基本单元（最小单元），pod 内部是容器，k8s 不直接管理容器，而是管理pod；
- docker 运行容器的基础环境，容器引擎；
- fluentd 日志收集服务；

在介绍完 K8s 架构后，我们又引入了很多技术名词。不要着急，先有**整体概念，再各个击破**。请耐心阅读下文，相信你一定会有不一样的收获。

## K8s 核心组件

1.K8s 组件

K8s 是用来管理容器，但是不直接操作容器，最小操作单元是 Pod （间接管理容器）

- 一个 Master 有一群 Node 节点与之对应
- Master 节点不存储容器，只负责调度、网管、控制器、资源对象存储
- 容器的存储在 Node 节点，容器是存储在 Pod 内部的）
- Pod 内部可以有一个容器，或者多个容器
- Kubelet 负责本地 Pod 的维护
- Kube-proxy 负责负载均衡，在多个 Pod 之间来做负载均衡

2.Pod 是什么？

- pod 是看s最小操作单元，Pod 用来封装容器的一个容器，Pod 是一个虚拟化分组；
- Pod 相当于独立主机，可以封装一个或者多个容器；

Pod 有自己的 IP 地址、主机名，相当于一台独立沙箱环境。

3.Pod 到底用来干什么？

通常情况下，在服务部署时候，使用 Pod 来管理一组相关的服务。一个 Pod 中要么部署一个服务，要么部署一组有关系的服务。

一组相关的服务是指：在链式调用的调用连路上的服务。

4.Web 服务集群如何实现？

实现服务集群：只需要复制多方 Pod 的副本即可，这也是 K8s 管理的先进之处，K8s 如果继续扩容，只需要控制 Pod 的数量即可，缩容道理类似。

5.Pod 底层网络，数据存储是如何进行的？

- Pod 内部容器创建之前，必须先创建 Pause 容器；
- 服务容器之间访问 localhost ，相当于访问本地服务一样，性能非常高；

6.ReplicaSet 副本控制器

控制 Pod 副本「服务集群」的数量，永远与预期设定的数量保持一致即可。当有 Pod 服务宕机时候，副本控制器将会立马重新创建一个新的 Pod，永远保证副本为设置数量。

副本控制器：标签选择器-选择维护一组相关的服务（它自己的服务）

```
selector：     
  app = web    
  Release = stable 
```

7.Deployment 部署对象

- 服务部署结构模型
- 滚动更新

ReplicaSet 副本控制器控制 Pod 副本的数量。但是，项目的需求在不断迭代、不断的更新，项目版本将会不停的的发版。版本的变化，如何做到服务更新？

部署模型：

- ReplicaSet 不支持滚动更新，Deployment 对象支持滚动更新，通常和 ReplicaSet 一起使用；
- Deployment 管理 ReplicaSet，RS 重新建立新的 RS，创建新的 Pod；

8.MySQL 使用容器化部署，存在什么样的问题？

- 容器是生命周期的，一旦宕机，数据丢失
- Pod 部署，Pod 有生命周期，数据丢失

对于 K8s 来说，不能使用 Deployment 部署**有状态**服务。

通常情况下，Deployment 被用来部署无状态服务，那么对于有状态服务的部署，使用 StatefulSet 进行有状态服务的部署。

什么是**有状态服务**？

- 有实时的数据需要存储
- 有状态服务集群中，把某一个服务抽离出去，一段时间后再加入机器网络，如果集群网络无法使用

什么是**无状态服务**？

- 没有实时的数据需要存储
- 无状态服务集群中，把某一个服务抽离出去，一段时间后再加入机器网络，对集群服务没有任何影响

9.StatefulSet

为了解决有状态服务使用容器化部署的一个问题。

- 部署模型
- 有状态服务

StatefulSet 保证 Pod 重新建立后，Hostname 不会发生变化，Pod 就可以通过 Hostname 来关联数据。

## 关键问题

**1.企业使用K8s主要用来做什么？**

- **自动化运维平台**

  创业型公司，中小型企业，使用 K8s 构建一套自动化运维平台，自动维护服务数量，保持服务永远和预期的数据保持一致性，让服务可以永远提供服务。这样最直接的好处就是降本增效。
  
- **充分利用服务器资源**

  互联网企业，有很多服务器资源「物理机」，为了充分利用服务器资源，使用 K8s 构建私有云环境，项目运行在云。**这在大型互联网公司尤为重要**。

- **服务的无缝迁移**

  项目开发中，产品需求不停的迭代，更新产品。这就意味着项目不停的发布新的版本，而 K8s 可以实现项目从开发到生产无缝迁移。

