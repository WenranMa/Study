# Network

## 简介

### 定义
欧拉的七座桥问题，衍生出拓扑学。计算机网络拓扑结构是指网络中各个站点相互连接的形式。

计算机网络，是指将地理位置不同的、具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。

- 连通性
- 共享性

### 发展

ENIAC，全称为Electronic Numerical Integrator And Calculator，即电子数字积分计算机。

SAGE(赛其)半自动地面防空系统20世纪50年代初，美国为了自身的安全，在美国本土北部和加拿大境内，建立了一个半自动地面防空系统，简称SAGE系统。译成中文叫赛其系统。

1969年美国国防部高级研究计划署（ARPA）建立ARPANet。ARPANet最初只包括四个站点，即加州大学洛杉矶分校UCLA、加州大学圣巴巴拉分校UCSB、犹他大学Utah和斯坦福研究所SRI。ARPANet开始采用由加州大学洛杉矶分校的斯蒂夫.克洛克设计的网络控制协议NCP（Network Control Protocol）。1971年ARPANet发展到15个站点，23台主机。新接入的站点包括哈佛大学、斯坦福大学、林肯实验室、麻省理工学院、卡内基.梅隆大学、美国航空航天局的Ames研究中心等。1972年互联网工作组（INWG）宣告成立。其目的在于建立互联网通讯协议，主席是斯坦福的温登.泽夫。1973 年ARPANet扩展成国际互联网。第一批接入的有英国和挪威的计算机。

计算机网络协议是有关计算机网络通信的一整套规则，或者说是为完成计算机网络通信而制订的规则、约定和标准。网络协议由语法、语义和时序三大要素组成；语法是指通信数据和控制信息的结构与格式；语义是对具体事件应发出何种控制信息，完成何种动作以及做出何种应答；时序是对事件实现顺序的详细说明。每种网络协议都有自己的优点，但只有TCP/IP允许与Internet完全的连接。

互联网、因特网、万维网三者的关系是：互联网包含因特网，因特网包含万维网。凡是能彼此通信的设备组成的网络就叫互联网。所以，即使仅有两台机器，不论用何种技术使其彼此通信，也叫互联网。国际标准的互联网写法是internet，字母i一定要小写！因特网是互联网的一种。因特网可不是仅有两台机器组成的互联网，它是由上千万台设备组成的互联网。因特网使用TCP/IP协议让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。判断自己是否接入的是因特网，首先是看自己电脑是否安装了 TCP/IP协议，其次看是否拥有一个公网地址（所谓公网地址，就是所有私网地址以外的地址）。国际标准的因特网写法是Internet，字母I一定要大写！

因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要应用层使用的是HTTP协议，就称为万维网（World Wide Web）。之所以在浏览器里输入百度网址时，能看见百度网提供的网页，就是因为您的个人浏览器和百度网的服务器之间使用的是HTTP协议在交流。

### ISP
ISP(Internet Service Provider)，互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。

### NAP
网络接入点

## 网络协议
### OSI
OSI/RM Open System Interconnection/Reference Model

  OSI,开放系统互联模型。

| Level | EN   |数据单位 | 解释 |
| ----- | ---- |---- | ------- |
| 应用层 | Application  | APDU | 用户接口，比如浏览器界面 |
| 表示层 | Presentation | PPDU | 数据表现形式，ASCII, mp3, jpg, 压缩，加密 |
| 会话层 | Session      | SPDU | 管理会话层，建立，管理，结束会话。比如判断是否给传输层 |
| 传输层 | Transport    | TPDU | TCP/UDP可靠或不可靠传输，端口号 |
| 网络层 | Network      | 报文 | 存着IP地址，用于外网通信 |
| 数据链路层 | Data Link | 帧 | 帧中存储着MAC地址，也就是网卡的物理地址，负责局域网络 | 
| 物理层 | Physical    |Bit | 比特流传输，物理接口，电气特性 |

上层最接近用户。上三层给用户提供服务，没有网络也需要这三层，下四层用于数据传输。PDU: Protocol Data Unit。

第七层应用层：应用层是OSI参考模型中的最高层，也是最接近用户的一层，用户可以利用不同的应用软件产生或得到不同类型（例如语音、文字、图片等）的网络数据。这一层主要是为操作系统或网络应用程序提供访问网络服务的接口。

第六层表示层：这一层提供格式化的表示和转换数据服务，解决上一层用户信息的语法表示问题，对数据进行压缩、格式转换、加密和解密等工作，并为下一层实现其功能做好准备。

第五层会话层：该层负责在两个节点间建立端与端的连接，进行对话的连接、管理和拆除，但是会话层并不参与具体的传输。在表示层和会话层数据被转换为数据单元。

第四层传输层：数据经过前三层已经做好了传输的准备，而在传输层上数据单元变为段或者报文，该层提供端到端（最终用户到最终用户）的透明的、可靠地数据传输服务，并处理端到端的差错控制和流程控制问题。

第三层网络层：计算机网络通信中会经过多个数据链路和通信子网，网络层就是选择合适的网间路由和交换节结点，来确保数据的及时传输。此外，在这一层还可以实现网络的拥塞控制、网际互连等功能。在这一层中通过IP地址来寻址，数据以分组为单位，称为报文分组数据。

第二层数据链路层：该层也用于数据传输，与网络层不同的，在这一层中通过MAC地址（物理地址）来寻址，并且给保温分组数据加上头部与尾部，变为我们所熟知的帧。数据链路层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路改造成对网络层来说无差错的数据链路，并且进行流量控制防止阻塞。

第一层物理层：物理层是最底层，如果说前几个层次的数据变化和传输比较虚拟，那在物理层数据就在具体的物理媒介中进行传输，此时数据被称为比特流。物理层上的传输介质有很多，例如我们熟知的光纤，双绞线，同轴电缆，无线电波等介质。

### TCP/IP

TCP/IP：Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又叫网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。

| Level | 解释 |
| ----- | ---- |
| 应用层 | 对应OSI上三层 FTP, Telnet, DNS, SMTP|
| 传输层 | OSI 传输层 TCP, UDP|
| 网际互联层 | OSI 网络层 IP协议，IGMP，ICMP互联网控制报文协议(ping)|
| 网络接口层 | OSI 下两层 ARP地址解析协议工作这层| 

与OSI参考模型不同，TCP/IP协议只有4个层次，从高到低分别为应用层、传输层、互联层和主机-网络层。TCP/IP协议中的应用层与OSI参考模型中的应用层、表示层和会话层相对应，执行它们所完成的任务，对数据做最初的处理形成数据单元，其中包含FTP、SMPT、DNS等协议；TCP/IP协议中的传输层和互联层与OSI参考模型中的传输层和网络层一一对应，完成这两层的任务，其中传输层中包含TCP和UDP这两个重要协议，互联层包含IP这个重要协议；而OSI参考模型中的数据链路层和物理层在TCP/IP协议中被分为一层即主机-网络层，其中包含Ethernet、Token Ring等协议

### FTP
FTP协议（文件传输协议File Transfer Protocol）工作在TCP/IP参考模型的应用层，是基于传输协议TCP的一个协议。同大多数Internet服务一样，FTP也是一个客户/服务器系统，即FTP协议包括两个重要的组成部分，FTP服务器和FTP客户端。FTP服务器用于存储和传送文件，用户使用FTP客户端通过FTP协议与服务器传送文件或访问位于服务器上的资源。

一个FTP服务器进程可以同时为多个客户进程提供服务。FTP服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有多个从属进程，负责处理单个请求。

主进程接收新请求的步骤是：
- 打开服务器端的21号端口，使控制连接链路打开；
- 服务器端等待客户进程发出连接请求，客户端打开一个临时的端口，用于进行数据连接；
- 服务器端接收到连接请求并响应，打开20号或其他大于1024号的端口用于数据连接，并建立起数据连接；
- 服务器端启动从属进程来处理客户进程发出的请求；
- 从属进程对客户进程处理完毕后，客户端发送关闭连接请求，服务端响应后终止此次文件传输；
- 服务器端回到等待状态，继续接受其他进程发送的请求。

要注意的是，主进程与从属进程的处理是并发进行的。

FTP支持两种工作模式，一种叫做Port模式（主动模式），另一种为Passive模式（被动模式）。在主动模式下，客户端现在FTP服务器的21号端口建立连接，发送Port命令，并打开一个随机端口与服务器端的20号端口进行数据发送和接收；而在被动模式下，客户端发送的不是Port命令而是Passive命令，而且服务器端与客户端进行数据连接时打开的是一个大于1024号的端口，不再是确定的20号端口。由于Passive模式下在服务器端打开的是一个任意端口，很多防火墙设置的时候不允许接收外部发起的连接，所以许多防火墙或者内网的FTP服务器不支持Passive模式。

对于搭建FTP服务器，通常可以使用Server U软件；而对于FTP客户端，简单的我们可以直接利用浏览器，当然也可以使用专门的软件，例如CuteFTP、FlashFTP、FTP Explorer等。

 

## HTTP

### HTTP请求的Headers里所包含的部分详解


### 0. 什么是网络协议，为什么要对网络协议分层 ?
网络协议是计算机在通信过程中要遵循的一些约定好的规则。

- 易于实现和维护，因为各层之间是独立的，层与层之间不会收到影响。
- 有利于标准化的制定

### 1. HTTP 常用的状态码及其含义？

- 101:  切换请求协议
- 200：**（请求成功）**。服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 301 ： (永久移动，**永久性重定向，会缓存**) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
- 302：(临时移动，**临时重定向，不会缓存**) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 400 ：客户端请求有语法错误，不能被服务器所理解。
- 403 ：服务器收到请求，但是拒绝提供服务，服务器禁止访问，权限有关。
- 404 ：(未找到) 服务器找不到请求的网页。
- 494:请求头太大
- 495:https证书错误
- 496:https 没有证书
- 497:http到https
- 498:取消
- 499:客户端关闭链接（服务器端处理的时间过长，客户端“不耐烦”了，断开了链接。）
  - 代理服务器认为客户端发起的请求过于危险，所以主动切断了
  - 代理服务器没有办法连接到其他服务，导致timeout
- 500： (服务器内部错误) 服务器遇到错误，无法完成请求。
- 502:  网关错误
- 504:  网关超时

状态码开头代表类型：
- 1xx: 信息性状态码
- 2xx: 成功
- 3xx: 重定向
- 4xx: 客户端错误
- 5xx: 服务器错误

#### 1.1 状态码301和302的区别是什么？

**共同点**：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（**用户看到的效果就是他输入的地址A瞬间变成了另一个地址B**）。
**不同点**：301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。

**补充，重定向原因**：
1. 网站调整（如改变网页目录结构）；
2. 网页被移到一个新地址；
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

#### 1.2 状态码502、504的区别是什么？
- 502是网关错误，504是网关超时
- 二者很类似，502是代理服务器后面的真实服务器节点配置出了问题或者已经挂掉了，而504是代理服务器后面的真实服务器已经过载，它要处理的请求报文实在太多，忙不过来了。
- 502还有一种情况就是nginx与fastcgi即PHP进程配合的不恰当，导致返回502网关错误。

### 2. HTTP 常用的请求方式，区别和用途？

| 方法    | 作用                                                        |
| ------- | ----------------------------------------------------------- |
| GET     | 获取资源                                                    |
| POST    | 传输实体主体，用于发送包含用户提交数据的请求                |
| PUT     | 上传文件，像服务器提交数据，以 **修改** 数据                |
| DELETE  | 删除文件，删除服务器上的某些资源                            |
| HEAD    | 和GET方法类似，但只返回报文**首部**，不返回报文实体主体部分 |
| PATCH   | 对资源进行部分修改                                          |
| OPTIONS | 查询指定的URL支持的方法，返回所有可用的方法，常用于**跨域** |
| CONNECT | 要求用ssl隧道协议连接**代理**                               |
| TRACE   | 服务器会将通信路径返回给客户端，追踪请求-响应的传输路径     |

为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。

- PUT：上传文件，向服务器添加数据，可以看作增
- DELETE：删除文件
- POST：传输数据，向服务器提交数据，对服务器数据进行更新。
- GET：获取资源，查询服务器资源

#### 2.2  get请求和post请求的区别
-  GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。 
-  GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。 
-  POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。 

**本质区别**

GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。

幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。

### 3. 请简单说一下你了解的端口及对应的服务？
- 22 ssh
- 3306 mysql
- 80 http
- 443 https
- 21 ftp
- 25 smtp

### 4. 说下计算机网络体系结构

**思路:** 这道题主要考察候选人，**计算机网络体系结构**这个基础知识点。计算机网路体系结构呢，有三层：ISO 七层模型、TCP/IP 四层模型、五层体系结构。大家可以记住这个图，如下

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344507793-5f9c3745-ad90-47eb-9815-6319ebef6644.png)

计算机网络体系结构

#### 4.1 七层模型

- 应用层：网络服务与最终用户的一个接口，常见的协议有：**HTTP FTP  SMTP SNMP DNS**.
- 表示层：数据的表示、安全、压缩。，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
- 会话层：建立、管理、终止会话, 对应主机进程，指本地主机与远程主机正在进行的会话.
- 传输层：定义传输数据的协议端口号，以及流控和差错校验, 协议有**TCP UDP**.
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择, 协议有**ICMP IGMP IP 等**.
- 数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。
- 物理层：建立、维护、断开物理连接。

![img](https://cdn.nlark.com/yuque/0/2021/png/450565/1635822448133-aadaef56-166b-4415-98d7-f574b90ad228.png)

#### 4.2 TCP/IP 四层模型

- 应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。
- 传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。
- 网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。
- 网络接口层：与 OSI 参考模型的数据链路层、物理层对应。

#### 4.3 五层体系结构

- 应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。
- 传输层：对应 OSI 参考模型的的传输层
- 网络层：对应 OSI 参考模型的的网络层
- 数据链路层：对应 OSI 参考模型的的数据链路层
- 物理层：对应 OSI 参考模型的的物理层。

### 5 如何理解 HTTP 协议是无状态的

HTTP的无状态，指协议对于事务处理没有记忆能力，不对通信状态进行保存，服务器无法判断用户身份。即打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。服务器不会去记住你是谁，所以是无状态协议。

### 6. 从浏览器地址栏输入 url 到显示主页的过程

1. DNS 解析，查找域名对应的 IP 地址。
2. 与服务器通过三次握手，建立 TCP 连接
3. 向服务器发送 HTTP 请求
4. 服务器处理请求，返回网页内容
5. 浏览器解析并渲染页面
6. TCP 四次挥手，连接结束

### 在浏览器中输入www.baidu.com后执行的全部过程？

1.  域名解析（域名 [www.baidu.com ](http://www.baidu.com/)变为 ip 地址）。
   **浏览器搜索自己的DNS缓存**（维护一张域名与IP的对应表）；若没有，则搜索**操作系统的DNS缓存**（维护一张域名与IP的对应表）；若没有，则搜索操作系统的**hosts文件**（维护一张域名与IP的对应表）。
   若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即**本地 dns 服务器**（递归查询），**本地域名服务器查询自己的dns缓存**，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。 
2.  发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 **80** 端口发起 tcp 的连接。 
3.  建立 tcp 连接后发起 http 请求。 
4.  服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。 
5.  浏览器解析 html 代码，并请求 html 中的资源。 
6.  浏览器对页面进行渲染，并呈现给用户。 


附一张形象的图片：![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1663053788861-089244c7-6b02-43cf-9be2-8af416b87c4a.png)


### 7. 说下 HTTP/1.0，1.1，2.0 的区别

记住**HTTP/1.0**默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用**多路复用**就差不多啦。

**HTTP/1.0**

- 默认使用**短连接**，每次请求都需要建立 TCP 连接。服务完成立即断开，开销大；
- 错误状态响应码少；
- 不支持断点续传。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

**HTTP/1.1**

- 默认长连接，即 TCP 连接默认不关闭，可以被多个请求复用。
- 分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。请求头引入了range头域，它允许只请求资源的某个部分
- 管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。
- 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
- 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

**HTTP/2.0**

- 二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制，实现方便，健壮性更好。
- 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 报头压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送，同时通信的双方各自缓存一份header fields表，避免了header的重复传输。
- 服务端推送：允许服务器未经请求，主动向客户端发送资源。

#### 7.1 长连接和短连接？

`HTTP协议的长连接和短连接，实质上就是TCP协议的长连接和短连接。`

#### 短链接

**在HTTP/1.0中，默认使用的是短连接**。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

#### 长链接：
**HTTP/1.1起，默认使用长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：`Connection:keep-alive`

在使用**长连接**的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。AKA: TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求

**长连接的生命周期** ：
正常情况下，一条TCP长连接建立后，只要双不提出关闭请求并且不出现异常情况，这条连接是一直存在的.操作系统不会自动去关闭它，甚至经过物理网络拓扑的改变之后仍然可以使用。所以一条连接保持几天、几个月、几年或者更长时间都有可能，只要不出现异常情况或由用户（应用层）主动关闭。客户端和服务单可一直使用该连接进行数据通信。

**长连接的优点：**

- 长连接可以省去较多的TCP建立和关闭的操作，减少网络阻塞的影响，
- 当发生错误时，可以在不关闭连接的情况下进行提示，
- 减少CPU及内存的使用，因为不需要经常的建立及关闭连接。

**长连接的缺点：**

- 连接数过多时，影响服务端的性能和并发数量。

**使用场景**
- 数据库的连接就是采用TCP长连接.
- RPC，远程服务调用，在服务器，一个服务进程频繁调用另一个服务进程，可使用长连接，减少连接花费的时间。


### 8 长链接的实现及心跳机制：

#### 心跳机制
应用层协议大多都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线。并传输一些可能必要的数据。使用心跳包的典型协议是IM，比如QQ/MSN/飞信等协议。在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。

系统**默认是设置的2小时**的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。

#### 为什么需要心跳机制？
因为网络的不可靠性, 有可能在 TCP 保持长连接的过程中, 由于某些突发情况, 例如网线被拔出, 突然掉电等,

会造成服务器和客户端的连接中断. 在这些突发情况下, 如果恰好服务器和客户端之间没有交互的话, 那么它们是不能在短时间内发现对方已经掉线的.

心跳机制即可解决此类问题。使用心跳来判断client是否还连接到server上。

#### TCP协议的KeepAlive机制
默认KeepAlive状态是不打开的。需要将setsockopt将SOL_SOCKET.SO_KEEPALIVE设置为1才是打开KeepAlive状态，并且可以设置三个参数：**tcp_keepalive_time ，tcp_keepalive_probes ， tcp_keepalive_intvl**，分别表示：连接闲置多久开始发keepalive的ack包、发几个ack包不回复才当对方已断线、两个ack包之间的间隔。

很多网络设备，尤其是NAT路由器，由于其硬件的限制（例如内存、CPU处理能力），无法保持其上的所有连接，因此在必要的时候，会在连接池中选择一些不活跃的连接踢掉。

典型做法是LRU，把最久没有数据的连接给T掉。通过使用TCP的KeepAlive机制（修改那个time参数），可以让连接每隔一小段时间就产生一些ack包，以降低被踢掉的风险，当然，这样的代价是额外的网络和CPU负担。

#### 如何实现心跳机制？

两种方式实现心跳机制:

- 使用 TCP 协议层面的 keepalive 机制.
- 在应用层上实现自定义的心跳机制.

虽然在 TCP 协议层面上, 提供了 keepalive 保活机制, 但是使用它有几个缺点:

1. 它不是 TCP 的标准协议, 并且是默认关闭的.
2. TCP keepalive 机制依赖于操作系统的实现, 默认的 keepalive 心跳时间是 **两个小时**, 并且对 keepalive 的修改需要系统调用(或者修改系统配置), 灵活性不够.
3. TCP keepalive 与 TCP 协议绑定, 因此如果需要更换为 UDP 协议时, keepalive 机制就失效了.

使用 TCP 层面的 keepalive 机制比自定义的应用层心跳机制节省流量,

### 9. 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？

这个问题记住`keep-alive`就好，也就是说，在 HTTP 中响应体的**Connection**字段指定为`keep-alive`即可

### 10. HTTP 如何实现长连接？在什么时候会超时？

**思路:** 这道题实际上是考察 TCP 长连接的知识点，HTTP 的长连接实质是指 TCP 的长连接。至于什么时候超时，我们记住这几个参数如**tcp_keepalive_time**、**tcp_keepalive_probes**就好啦

通过在头部（请求和响应头）设置**Connection**字段指定为`keep-alive`，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。

- HTTP 一般会有 httpd 守护进程，里面可以设置**keep-alive timeout**，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间
- TCP 的**keep-alive**包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了**tcp_keepalive_time**，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了**tcp_keepalive_probes**，就会丢弃该连接。

### 11. HTTP 与 HTTPS 的区别

HTTP，即超文本传输协议，是一个基于 TCP/IP 通信协议来传递明文数据的协议。HTTP 会存在这**几个问题**：

- 请求信息是明文传输，容易被窃听截取。
- 没有验证对方身份，存在被冒充的风险
- 数据的完整性未校验，容易被中间人篡改

为了解决 Http 存在的问题，Https 出现啦。

**Https 是什么？**

**HTTPS= HTTP+SSL/TLS**，可以理解 Https 是身披 SSL(Secure Socket Layer，安全套接层) 的 HTTP。

它们主要区别如下：

|              | **HTTP**           | **HTTPS**                               |
| ------------ | ------------------ | --------------------------------------- |
| 端口         | 80                 | 443                                     |
| 安全性       | 无加密，安全性较差 | 有加密机制，安全性较高                  |
| 资源消耗     | 较少               | 由于加密处理，资源消耗更多              |
| 是否需要证书 | 不需要             | 需要                                    |
| 协议         | 运行在TCP协议之上  | 运行在SSL协议之上，SSL运行在TCP协议之上 |

#### HTTPS 优点：
- 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
- HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

**缺点**：
- 在现有的证书机制下，中间人攻击依然有可能发生。
- HTTPS 需要更多的服务器资源，也会导致成本的升高。

#### Http 请求的过程与原理

**思路:** HTTP 请求，一个非常非常基础的知识点，一定需要掌握的。其实觉得跟浏览器地址栏输入 url 到显示主页这道题有点类似。

HTTP 是一个基于 TCP/IP 协议来传递数据的超文本传输协议，传输的数据类型有 HTML, 图片等。

Http 请求过程

1. 客户端进行 DNS 域名解析，得到对应的 IP 地址
2. 根据这个 IP，找到对应的服务器建立连接（三次握手）
3. 建立 TCP 连接后发起 HTTP 请求（一个完整的 http 请求报文）
4. 服务器响应 HTTP 请求，客户端得到 html 代码
5. 客户端解析 html 代码，用 html 代码中的资源 (如 js,css, 图片等等) 渲染页面。
6. 服务器关闭 TCP 连接（四次挥手）

### 12 . Https 流程是怎样的？

**思路:** 这道题实际上考察的知识点是 HTTPS 的工作流程，大家需要回答这几个要点，**公私钥、数字证书、加密、对称加密、非对称加密**。

- HTTPS = HTTP + SSL/TLS，也就是用 SSL/TLS 对数据进行加密和解密，Http 进行传输。
- SSL，即 Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。
- TLS，即 Transport Layer Security(安全传输层协议)，它是 SSL3.0 的后续版本。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219634/1647602540550-ddfcb15e-1ee8-407d-a39a-b64c13f48082.png)

**Https 工作流程**

1. 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。
2. 采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
5. 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
6. 服务器在收到随机码 KEY 之后会使用私钥B将其 非对称 解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
7. 服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。
8. 双方使用对称加密愉快地传输所有数据。

#### 12.1 SSL安全套接字层协议作用？

作用是建立安全连接，能和多个应用层协议协和使用保证安全传输。

- 记录协议：接收消息并处理，然后将处理过的消息继续传递。包括加解密、解压缩、分段重组等。
- 握手协议：建立在三次握手之后，为建立安全连接提供参数并进行双方的真实性认证。
- 警告协议：规定可能出现的错误等级和应对方式。
- 密码规范改变协议：在握手结束前发送，通知对方在之后的消息中使用商量好的加密算法。

### 13. HTTP请求报文和响应报文的格式？

**请求报文格式**：

1. 请求行（请求方法+URI协议+版本）
2. 请求头部
3. 空行
4. 请求主体

```
GET/sample.jspHTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=jinqiao&password=1234 请求主体
```
**响应报文**：

1. 状态行（版本+状态码+原因短语）
2. 响应首部
3. 空行
4. 响应主体
```
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

<html>
   <head>
     <title>HTTP响应示例<title>
   </head>
   <body>
     Hello HTTP!
   </body>
</html>
```

### 14. 说说什么是数字签名？什么是数字证书？

数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。它的出现，是为了避免身份被篡改冒充的。比如 Https 的数字证书，就是为了避免公钥被中间人冒充篡改：![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344509790-f338cc55-34e6-4c56-96d4-fcb3b7851467.png)

**数字证书构成**

- 公钥和个人等信息，经过 Hash 摘要算法加密，形成消息摘要；将消息摘要拿到拥有公信力的认证中心（CA），用它的私钥对消息摘要加密，形成**数字签名**。
- 公钥和个人信息、数字签名共同构成**数字证书**。

### 15. 对称加密与非对称加密有什么区别

对称加密：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344511455-364fd733-e783-4cdb-b2a8-c9fb8ba4933e.png)

非对称加密：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344511491-7bcdd3d6-c19f-41ce-861c-70b6f4c6db06.png)


### 16. 说说 DNS 的解析过程？

DNS，英文全称是**domain name system**，域名解析系统，是 Internet 上作为域名和 IP 相互映射的一个分布式数据库。它的作用很明确，就是可以根据域名查出对应的 IP 地址。在浏览器缓存、本地 DNS 服务器、根域名服务器都是怎么查找的，大家回答的时候都可以说下哈。

DNS 的解析过程如下图：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344511680-72cde8e6-237e-4c3b-bb58-6b526b3aad26.png)

DNS 解析查找过程

假设你要查询**www.baidu.com**的 IP 地址:

- 首先会查找浏览器的缓存, 看看是否能找到**www.baidu.com**对应的 IP 地址，找到就直接返回；否则进行下一步。
- 将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步；
- 本地 DNS 服务器向**根域名服务器**发送请求，根域名服务器返回负责`.com`的顶级域名服务器的 IP 地址的列表。
- 本地 DNS 服务器再向其中一个负责`.com`的顶级域名服务器发送一个请求，返回负责`.baidu`的权威域名服务器的 IP 地址列表。
- 本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，返回**www.baidu.com**所对应的 IP 地址。


### 17. 什么是 CSRF 攻击，如何避免

CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。

来看一个来自百度百科的例子哈：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344511690-6acdb027-612e-4d8c-bcd7-61c33aac6e9b.png)

1. Tom 登陆银行，没有退出，浏览器包含了 Tom 在银行的身份认证信息。
2. 黑客 Jerry 将伪造的转账请求，包含在在帖子
3. Tom 在银行网站保持登陆的情况下，浏览帖子
4. 将伪造的转账请求连同身份认证信息，发送到银行网站
5. 银行网站看到身份认证信息，以为就是 Tom 的合法操作，最后造成 Tom 资金损失。

**怎么解决 CSRF 攻击呢？**

- 检查 Referer 字段。
- 添加校验 token。

### 18. 聊聊五层计算机网络体系结构中，每一层对应的网络协议有哪些？

为了大家方便记忆，画了个思维导图，如下：
![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344511729-74537b4b-de23-4710-87a8-b975951ddb31.png)


### 19. 说说 WebSocket 与 socket 的区别

- Socket 其实就是等于**IP 地址 + 端口 + 协议**。

具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。

- WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决**http 不支持持久化连接**的问题。
- Socket 一个是**网编编程的标准接口**，而 WebSocket 则是应用层通信协议。

### 20. 什么是 DoS、DDoS、DRDoS 攻击？

- **DOS**: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起 DOS 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有**计算机网络宽带攻击**、**连通性攻击**。
- **DDoS**: (Distributed Denial of Service), 翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。常见的 DDos 有**SYN Flood、Ping of Death、ACK Flood、UDP Flood**等。
- **DRDoS**: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。

DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：

1. 客户端向服务端发送请求链接数据包。
2. 服务端向客户端发送确认数据包。
3. 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。

DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：

- **减少SYN timeout时间**。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。
- **限制同时打开的SYN半连接数目。**

SYN flood 洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。

原理：

- 在三次握手过程中，服务器发送 [SYN/ACK] 包（第二个包）之后、收到客户端的 [ACK] 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV（等待客户端响应）状态。如果接收到客户端的 [ACK]，则 TCP 连接成功，如果未接受到，则会**不断重发请求**直至成功。
- SYN 攻击的攻击者在短时间内**伪造大量不存在的 IP 地址**，向服务器不断地发送 [SYN] 包，服务器回复 [SYN/ACK] 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。
- 这些伪造的 [SYN] 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。

检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。

防范：

- 通过防火墙、路由器等过滤网关防护。
- 通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。
- SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。

### 21. 什么是 XSS 攻击，如何避免?

**思路:** XSS 攻击也是比较常见，XSS，叫**跨站脚本攻击（Cross-Site Scripting）**，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。XSS 攻击一般分三种类型：**存储型 、反射型 、DOM 型 XSS**

这种攻击是**由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的**。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入**带有＜script＞标签的代码**，导致恶意代码的执行。


#### 21.1 XSS 是如何攻击的呢？

拿反射型举个例子吧，流程图如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344512594-37d2cda6-b1cd-49bc-9f96-1c971a5466bf.png)

#### 21.2 如何解决 XSS 攻击问题？

- 对输入进行过滤，过滤标签等，只允许合法值。
- HTML 转义
- 对于链接跳转，如`<a href="xxx"` 等，要校验内容，禁止以 script 开头的非法链接。
- 限制输入长度

### 23.  forward 和 redirect 的区别？

**思路:** 这道题有点偏 Java web 方向的。以前记得刚出来实习找工作的时候，面试官可喜欢问这道题啦，当时我记的答案就是，forward 是转发，redirect 是重定向。

- **直接转发方式（Forward）** ，客户端和浏览器只发出一次请求，服务端 转发。
- **间接转发方式（Redirect）** 实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。

- Redirect 的工作原理：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344512999-badb6a58-4403-4881-9107-bde49da48798.png)

- forward 的工作原理

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344513019-b1e630c0-6891-4b31-9698-439609621927.png)


### 24. 聊聊 SQL 注入？

SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

**SQL注入的原理主要有以下 4 点**

- 恶意拼接查询
- 利用注释执行非法命令
- 传入非法参数
- 添加额外条件

**避免SQL注入的一些方法**：

- 限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。
- 对进入数据库的特殊字符（’”\尖括号&*;等）转义处理。
- 提供参数化查询接口，不要直接使用原生SQL。

SQL 注入是一种代码注入技术，一般被应用于攻击 web 应用程序。它通过在 web 应用接口传入一些特殊参数字符，来欺骗应用服务器，执行恶意的 SQL 命令，以达到非法获取系统信息的目的。它目前是黑客对数据库进行攻击的最常用手段之一。

#### 24.1 SQL 注入是如何攻击的？

举个常见的**业务场景**：在 web 表单搜索框输入员工名字，然后后台查询出对应名字的员工。这种场景下，一般都是前端页面, 把一个名字参数 name 传到后台，然后后台通过 SQL 把结果查询出来

```sql
name = "田螺"; -- 前端传过来的
-- 根据前端传过来的 name 参数，查询数据库员工表 staff
SQL= "select * from staff where name=" + name;  
```
因为 SQL 是直接拼接的，如果我们完全信任前端传的参数的话。假如前端传这么一个参数时`''or'1'='1'`，SQL 就变成酱紫的啦。
```sql
select * from staff where name=''or'1'='1';
```
这个 SQL 会把所有的员工信息全都查出来了，酱紫就请求用户已经越权啦。请求者可以获取所有员工的信息，信息已经暴露了啦。

#### 24.2 如何预防 SQL 注入问题
- 佔位符 ? 代替 %s
- 如果 SQL 发生异常了，不要把这些信息暴露响应给用户，可以自定义异常进行响应
- 不相信任何外部输入参数，过滤参数中含有的一些数据库关键词关键词，比如过滤`union，or`等数据库关键词
- 适当的权限控制，在你查询信息时，先校验下当前用户是否有这个权限。比如说，实现代码的时候，可以让用户多传一个企业 Id 什么的，或者获取当前用户的 session 信息等，在查询前，先校验一下当前用户是否是这个企业下的等等，是的话才有这个查询员工的权限。


### 25. Session 和 Cookie 的区别

HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

#### Cookie 和 Session 是如何配合 如何保持会话状态？

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。

####  Cookie和Session的区别？

- 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
- 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。

#### 如何考虑分布式 Session 问题？

在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：

- **客户端存储**：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息
- **Nginx ip_hash 策略**：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。
- **Session 复制**：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。
- **共享 Session**：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。

建议采用共享 Session的方案。

#### 不同会话状态的区别

- Cookie：在客户端保存用户信息，安全性较差，并且浏览器会限制cookie数量。例如： 保存登录用户信息，下次自动填写登录信息；登录网 站后访问其他页面就不用登录。
- Session：在服务端记录用户状态，安全性较高，但占用服务器性能。例如：购物车添加物品，根据Session知道用户的购物车。
- Token：在客户端保存认证授权状态，适合前后端分离的项目(处于不同服务器)。


### 26. IP 地址有哪些分类？

一般可以这么认为，IP 地址 = 网络号 + 主机号。

1. 网络号：它标志主机所连接的网络地址表示属于互联网的哪一个网络。
2. 主机号：它标志主机地址表示其属于该网络中的哪一台主机。

IP 地址分为 A，B，C，D，E 五大类：

- A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。
- B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。
- C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。
- D 类地址 (224~239)：以 1110 开头，保留位多播地址。
- E 类地址 (240~255)：以 11110 开头，保留位为将来使用

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344514317-00a3581b-e3bf-4449-a5e2-483f23853ece.png)


### 27. 说下 ARP 协议的工作过程？

ARP 协议协议，**Address Resolution Protocol**，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射。

1. 首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。
2. 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。
3. 网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。
4. 源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。


### 28. 有了 IP 地址，为什么还要用 MAC 地址？

- 简而言之，标识网络中的一台计算机，比较常用的就是**IP 地址和 MAC 地址**，但计算机的 IP 地址可由用户自行更改，管理起来就相对困难，而 MAC 地址不可更改，所以一般会把 IP 地址和 MAC 地址组合起来使用。
- 那只使用 MAC 地址不用 IP 地址行不行呢？不行的！因为最早就是 MAC 地址先出现的，并且当时并不用 IP 地址，只用 MAC 地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。
- 那为什么要用 IP 地址呢？是因为 IP 地址是和地域相关的，对于同一个子网上的设备，IP 地址的前缀都是一样的，这样路由器通过 IP 地址的前缀就知道设备在在哪个子网上了，而只用 MAC 地址的话，路由器则需要记住每个 MAC 地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。
- IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。


## TCP

### 29. TCP 和 UDP 分别对应的常见应用层协议有哪些？

**基于 TCP 的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**

- **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口 80
- **FTP**: File Transfer Protocol (文件传输协议), 默认端口 (20 用于传输数据，21 用于传输控制信息)
- **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) , 默认端口 25
- **TELNET**: Teletype over the Network (网络电传), 默认端口 23
- **SSH**：Secure Shell（安全外壳协议），默认端口 22

**基于 UDP 的应用层协议：DNS、TFTP、SNMP**

- **DNS** : Domain Name Service (域名服务), 默认端口 53
- **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口 69
- **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过 UDP 端口 161 接收，只有 Trap 信息采用 UDP 端口 162。

### 30. 聊聊保活计时器的作用（客户端连接成功之后发生故障怎么处理）

除时间等待计时器外，TCP 还一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若**连续发送 10 个探测报文段**后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

### 31. 如果服务器出现了大量 CLOSE_WAIT 状态如何解决。

我们先来复习下 TCP 的四次挥手

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344514375-b3395634-6b7f-46a0-bef5-03e911033c1a.png)

- 服务器端收到客户端发送的`FIN`后，TCP 协议栈就会自动发送 ACK，接着进入**CLOSE_WAIT**状态。
- 但是如果服务器端不执行 socket 的 close() 操作，那么就没法进入 LAST_ACK, 导致大量连接处于 CLOSE_WAIT 状态
- 所以，如果服务器出现了大量**CLOSE_WAIT**状态，一般是程序 Bug，或者关闭 socket 不及时。


### 32. URI 和 URL 的区别
- URI，全称是 Uniform Resource Identifier，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。
- URL，全称是 Uniform Resource Location，中文翻译是统一资源定位符，主要作用是提供资源的路径。打个经典比喻吧，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人。

### 33. ICMP 协议的功能

ICMP,Internet Control Message Protocol ,Internet 控制消息协议。

- ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。
- 它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括**报告错误、交换受限控制和状态信息**等。
- 当遇到 IP 数据无法访问目标、IP 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 ICMP 消息。

比如我们日常使用得比较多的**ping**，就是基于 ICMP 的。


### 35. 说下 ping 的原理

ping，**Packet Internet Groper**，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态

一般来说，ping 可以用来检测网络通不通。它是基于`ICMP`协议工作的。假设**机器 A** ping**机器 B**，工作过程如下：

1. ping 通知系统，新建一个固定格式的 ICMP 请求数据包
2. ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层
3. IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包
4. 先获取目标机器 B 的 MAC 地址。
5. 数据链路层构建一个数据帧，目的地址是 IP 层传过来的**MAC 地址**，源地址是本机的**MAC 地址**
6. 机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。
7. 根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间
8. 最终显示结果有这几项：发送到目的主机的 IP 地址、发送 & 收到 & 丢失的分组数、往返时间的最小、最大 & 平均值

**总结**：ping的工作过程

1. 向目的主机发送多个ICMP回送请求报文
2. 根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。

### 36. TCP 的三次握手机制

**思路:** TCP 连接的三次握手机制，最重要的知识点，必须得会，通讯过程以及客户端、服务器的对应的状态都需要记住哈。

TCp 提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的就是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。我们一起来看下流程图哈：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219634/1647602328103-7bc0ffb1-b5c8-4744-ac16-aa3903d45ad2.png)

三次握手机制：

- 第一次握手：客户端请求建立连接，向服务端发送一个**同步报文**（SYN=1），同时选择一个随机数 seq = x 作为**初始序列号**，并进入SYN_SENT状态，等待服务器确认。
- 第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送**同步确认报文**（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为初始序列号，此时服务器进入SYN_RECV状态。
- 第三次握手：客户端收到服务端的确认后，向服务端发送一个**确认报文**（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。

理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

### 第三次客户端如果不给服务端发的话会有什么问题？三次握手连接阶段，最后一次ACK包丢失，会发生什么

**服务端：**

- 第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。
- 如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。

**客户端：**
两种情况：
1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态
2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包（异常终止报文）应答。

### 37. TCP 握手为什么是三次，为什么不能是两次？不能是四次？

确保可靠的通信通道，**让双方都确认对方和自己的接收和发送功能是正常的**。

将三次握手通俗的说。

1. 第一次握手，Server知道Client的发送能力和自己的接收能力是正常的。
2. 第二次握手，Client知道Server的发送和接收能力和自己的发送和接收能力是正常的，但是Server还不知道我的接收和他的发送能力正常与否。
3. 第三次握手，Client回馈，让Server知道自己的发送能力和Client的接收能力正常。

#### 为什么需要三次握手？
主要有三个原因：
1. 防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。
2. 三次握手才能让双方均确认自己和对方的发送和接收能力都正常。
3. 告知对方自己的初始序号值，并确认收到对方的初始序号值。

####  如果已经建立了连接，但是客户端出现故障了怎么办？

简而言之，通过**定时器 + 超时重试机制**，尝试获取确认，直到最后会自动断开连接。具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。

### 38. TCP 四次挥手过程

**思路:** TCP 的四次挥手，也是最重要的知识点，一般跟三次握手会一起考的，必须得记住。

![img](https://cdn.nlark.com/yuque/0/2021/png/450565/1635824366118-b5289b25-9da4-4f16-9b31-4b23c672c15a.png)

TCP 四次挥手过程

- Client状态变化：Fin-Wait-1 -> Fin-Wait-2 -> Time-Wait -> Closed
- Server状态变化：Close-Wait -> Last-Ack -> Closed

**具体流程：**

![img](https://cdn.nlark.com/yuque/0/2022/png/22219634/1647602328115-1d5927b9-4f27-4a21-9603-40272d988644.png)

- 第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。发送完毕后，客户端进入**FIN_WAIT_1**状态。

- - 序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1
    - 确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1

- 第二次挥手：服务端收到连接释放报文后，立即发出**确认报文**（ACK=1），序列号 seq = k，确认号 ack = u + 1。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。服务器端进入**CLOSE_WAIT**状态，客户端接收到这个确认包之后，进入**FIN_WAIT_2**状态。
- 第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。服务器端进入**LAST_ACK**状态，等待来自客户端的最后一个 ACK。

- - 序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。
    - 确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据

- 第四次挥手：客户端收到服务端的连接释放报文后，立即发出**确认报文**（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。此时，客户端就进入了 TIME-WAIT 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 CLOSED 状态。而服务端只要收到客户端发出的确认，就立即进入 CLOSED 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。

### 39. TCP 挥手为什么需要四次呢？

**总结：**

**Server端可能还有数据没有发送完毕**。Client发出连接释放通知，Server确认收到后，Client就进入半关闭状态（只收消息不发消息），Server把未发完的数据发送完毕后，发送连接释放通知，Client确认后就关闭连接。

服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.

接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的**ACK和FIN一般都会分开发送**，从而导致多了一次，因此一共需要四次挥手。


### 40. TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态

**思路：**  这个**问得频率特别高**。去面试前，一定要把这道题拿下哈。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344514848-17cf6476-7e2f-4276-bdb0-c84c281519cb.png)

2MSL，**two Maximum Segment Lifetime**，即两个最大段生命周期。假设**主动发起挥手的是客户端**，那么需要 2MSL 的原因是：

- **1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。**  这个 ACK 报文段有可能丢失，因而使处在**LAST-ACK**状态的服务端就收不到对已发送的**FIN + ACK**报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（**客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输**）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到**CLOSED**状态。（简述：防止ack报文丢失，Server再次发送Fin报文，一来一回最长时间就是2MSL）
- **2. 防止已失效的连接请求报文段出现在本连接中**。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

#### TIME-WAIT 状态过多会产生什么后果？怎样处理？

从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。

从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。

**解决办法：**

- 服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于TIME_WAIT状态），也请继续并重用它。
- 调整系统内核参数，修改/etc/sysctl.conf文件，即修改net.ipv4.tcp_tw_reuse 和 tcp_timestampsnet.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
    net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
- 强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。

#### TIME_WAIT 是服务器端的状态?还是客户端的状态?

TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。

TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。

### 41. TCP 的粘包和拆包

TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一**个完整的包可能会被 TCP 拆分成多个包进行发送**，**也有可能把多个小的包封装成一个大的数据包发送**，这就是所谓的 TCP 粘包和拆包问题。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344516284-c7f31605-4f37-47c4-99b3-2bc9ebae3590.png)

- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 > MSS。

**解决方案：** ？？

- 发送端将每个数据包封装为固定长度
- 在数据尾部增加特殊字符进行分割
- 将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。


### 42. TCP 的流量控制

TCP 三次握手，发送端和接收端进入到 ESTABLISHED 状态，它们即可以传输数据啦。

但是发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是**流量控制**。

TCP 通过滑动窗口来控制流量，我们看下流量控制的**简要流程**吧：

首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344516286-26f52683-e527-43c9-9a8e-4190f939e23f.png)

TCP 的流量控制

1. 假如当前发送方给接收方发送了 200 个字节，那么，发送方的`SND.NXT`会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。
2. 接受方收到后，放到缓冲队列里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节
3. 发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即 win=100 返回发送方。
4. 发送方继续干活，发送 100 字节过来，这时候，接受窗口 win 变为 0。
5. 发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。


### 43. 说说半连接队列和 SYN Flood 攻击的关系

TCP 进入三次握手前，服务端会从**CLOSED**状态变为**LISTEN**状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。

三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。

SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造**不存在的 IP 地址**, 向服务器大量发起 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的 TCP 请求啦。

那么有哪些方案应对呢？主要有 **syn cookie**和**SYN Proxy 防火墙**等。

- **syn cookie**：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
- **SYN Proxy 防火墙**：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。

### 44. TCP 的滑动窗口

TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。为了解决这个问题，TCP 引入了**窗口**，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。


为了避免这种情况，TCP引入了窗口概念。**窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值**。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219634/1647602328911-b9302924-b196-45de-bfcf-4820af360ae0.png)

从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。

滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。

**思路讲解：**  TCP 滑动窗口是个高频考点，我们需要知道 TCP 报文首部有个字段**win**控制窗口大小的，同时也需要掌握，滑动窗口是怎么滑的。

TCP 头部有个字段叫 win，也即那个**16 位的窗口大小**，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到**流量控制**的目的。通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是 win。

TCP 滑动窗口分为两种: 发送窗口和接收窗口。**发送端的滑动窗口**包含四大部分，如下：

- 已发送且已收到 ACK 确认
- 已发送但未收到 ACK 确认
- 未发送但可以发送
- 未发送也不可以发送

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344516506-14f515da-fdf5-4927-8d13-f756233d4e37.png)

- 虚线矩形框，就是发送窗口。
- SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 14 个，即发送窗口大小是 14。
- SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。
- SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。

接收方的滑动窗口包含三大部分，如下：

- 已成功接收并确认
- 未收到数据但可以接收
- 未收到数据并不可以接收的数据

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344516527-882ebb6a-d3ef-47fb-805b-f387dbc73507.png)

- 虚线矩形框，就是接收窗口。
- REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。
- REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。


### 45. TCP 的拥塞控制

**思路讲解：**  TCP 拥塞机制也是个高频考点，需要掌握**它跟流量控制**的区别，也需要掌握拥塞控制的这几种算法：**慢启动算法、拥塞避免、快速重传、快速恢复算法**。

拥塞控制是**作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况**。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟**流量控制**又有什么区别呢？流量控制是作用于接收者的，根据**接收端的实际接收能力控制发送速度**，防止分组丢失的。

发送方维护一个**拥塞窗口 cwnd（congestion window）** 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？

一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP 的描述就是：只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。

实际上，拥塞控制主要有这几种常用算法

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

![img](https://cdn.nlark.com/yuque/0/2021/png/450565/1635826255644-56476e84-0251-413a-b66b-2eed0a673df3.png)


#### 45.1 慢启动算法（慢开始）

cwnd初始值为1，每个轮次cwnd加倍

慢启动算法，表面意思就是，别急慢慢来。它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，**每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）**。**每轮次**发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。

- TCP 连接完成，初始化 cwnd = 1，表明可以传一个 MSS 单位大小的数据。
- 每当收到一个 ACK，cwnd 就加一;
- 每当过了一个 RTT，cwnd 就增加一倍; 呈指数让升

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344517436-e05cb41d-191c-49d1-8627-d95832e305f9.png)

为了防止 cwnd 增长过大引起网络拥塞，还需设置一个**慢启动阀值 ssthresh**（slow start threshold）状态变量。当`cwnd`到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当**cwnd >ssthresh**时，进入了**拥塞避免**算法。


#### 45.2 拥塞避免算法

慢开始门限ssthresh，当cwnd>ssthresh时，进入拥塞避免，让cwnd每个轮次+1。出现超时，就令ssthresh = cwnd/2，重新进行慢开始。

一般来说，慢启动阀值 ssthresh 是 65535 字节，`cwnd`到达**慢启动阀值**后

- 每收到一个 ACK 时，cwnd = cwnd + 1/cwnd
- 当每过一个 RTT 时，cwnd = cwnd + 1

显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344518890-92f3563c-6df1-42ca-8e48-8d62340ad068.png)

#### 45.3 拥塞发生(快速重传）

当网络拥塞发生**丢包**时，会有两种情况：

- RTO 超时重传
- 快速重传

如果是发生了**RTO 超时重传**，就会使用拥塞发生算法

- 慢启动阀值 sshthresh =  cwnd /2
- cwnd 重置为 1
- 进入新的慢启动过程

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344518944-cfb07c30-ee9f-44fe-a889-cabb5d21f4b2.png)

其实还有更好的处理方式，就是**快速重传**。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待**RTO 超时**再重传。

![img](https://cdn.nlark.com/yuque/0/2021/png/450565/1635826631264-3417488c-4cb1-44a0-af1b-6e21941ec84f.png)

慢启动阀值 ssthresh 和 cwnd 变化如下：

- 拥塞窗口大小 cwnd = cwnd/2
- 慢启动阀值 ssthresh = cwnd
- 进入快速恢复算法

#### 45.4 快速恢复

若丢失个别报文段，执行快恢复，令ssthresh = cwnd/2, cwnd = ssthresh，直接进入拥塞避免。快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：
```
- cwnd = cwnd /2 - sshthresh = cwnd
```

然后，真正的快速算法如下：

- cwnd = sshthresh  + 3
- 重传重复的那几个 ACK（即丢失的那几个数据包）
- 如果再收到重复的 ACK，那么 cwnd = cwnd +1
- 如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344518689-4b6fe3bc-58f3-45cd-9139-0ba041ee8bb1.png)

**总结：**

拥塞控制是为了**防止过多数据注入网络，导致网络过载**。TCP的拥塞控制采用四个算法实现：慢开始、拥塞避免、快重传、快恢复。 发送方维护一个拥塞窗口(cwnd)的状态变量。 

- **慢开始**：cwnd初始值为1，每个轮次cwnd加倍
- **拥塞避免**：慢开始门限ssthresh，当cwnd>ssthresh时，进入拥塞避免，让cwnd每个轮次+1。出现超时，就令ssthresh = cwnd/2，重新进行慢开始。
- **快重传**：接收方只对最后一个收到的有序报文段进行确认，若发送方介绍重复确认，就判断下一个报文段丢失，执行快重传，即立即重传下一报文段。
- **快恢复**：若丢失个别报文段，执行快恢复，令ssthresh = cwnd/2, cwnd = ssthresh，直接进入拥塞避免。 

### 46. TCP 和 UDP 的区别

**总结：**

- TCP：面向连接的可靠交付，以字节流传输，效率低，耗费资源少，适用于对通信数据严格的场景，如文件传输。首部20-60字节。
- UDP：无连接的尽最大努力交付，以数据报文段传输，速度快，耗费资源少，适用于对通信速度要求高的场景，如在线视频。首部8个字节。

**对比如下**：

|              | **UDP**                                    | **TCP**                                          |
| ------------ | ------------------------------------------ | ------------------------------------------------ |
| 是否连接     | 无连接                                     | 面向连接                                         |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制                 |
| 是否有序     | 无序                                       | 有序，消息在传输过程中可能会乱序，TCP 会重新排序 |
| 传输速度     | 快                                         | 慢                                               |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                                 |
| 传输方式     | 面向报文                                   | 面向字节流                                       |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                       |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输           |


####  UDP 和 TCP 对应的应用场景是什么？

TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP文件传输
- HTTP / HTTPS

UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP等
- 视频、音频等多媒体通信
- 广播通信

![img](https://cdn.nlark.com/yuque/0/2022/png/22219634/1647602328212-44fb55c6-cb03-486b-abe5-632261353a66.png)


#### 46.1 为什么视频用UDP

1. TCP需要三次握手，建立会话需要时间；
2. TCP在网络拥塞时，会调整滑动窗口大小，影响传输速度；
3. UDP无连接，没有拥塞控制，会以恒定速度发送数据，缺点是造成丢包，优点是实时性好。

#### 46.2 UDP处理丢包

1. 发生丢包，就立即发送冗余包，尽快恢复数据；
2. 建立长期参考帧，解决连贯性问题；
3. 发生网络抖动，降低码率，保证传输数据小于网络带宽。


### 47. TCP 是如何确保可靠性的呢？

**思路：**  TCP 是可靠的连接，为什么具有可靠性呢？记住这些点：连接和断开的可靠性（三次握手，四次挥手）、有状态（哪些数据发送了，哪些没发）、可控制（超时重传、流量控制、拥塞控制等）。

- 首先，TCP 的连接是基于**三次握手**，而断开则是基于**四次挥手**。确保连接和断开的可靠性。
- 其次，TCP 的可靠性，还体现在**有状态**;TCP 会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- 再次，TCP 的可靠性，还体现在**可控制**。它有数据包校验、ACK 应答、**超时重传 (发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可靠性传输。

- 检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。
- 序列号/确认应答：序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。


### 48. TCP 报文首部有哪些字段，其作用又分别是什么？

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344518826-14bb30cc-f006-4c15-b735-08768f246236.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/450565/1635822782859-97df9e6c-7172-46e3-b5ce-522257bd31f5.png)

- **16 位端口号**：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
- **32 位序号**：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- **32 位确认号**：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1。
- **4 位头部长度**：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节。
- **6 位标志位**：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
- **16 位窗口大小**：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- **16 位校验和**：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。
- **16 位紧急指针**：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。


### 49. Nagle 算法与延迟确认

#### 49.1 Nagle 算法

如果发送方疯狂地向接收方发送很小的数据包，比如一次就发送 1 个字节，那么显然会有问题。

TCP/IP 协议中，无论发送多少数据，总是需要在数据前面加上协议头，同时，对方接收到数据，也需要发送 ACK 表示确认。为了尽可能的利用网络带宽，TCP 总是希望尽可能的发送足够大的数据。**Nagle 算法**就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。

Nagle 算法：**任意时刻，最多只能有一个未被确认的小段**。所谓 “小段”，指的是小于 MSS 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。

Nagle 算法的实现规则：

- 如果包长度达到 MSS，则允许发送；
- 如果该包含有 FIN，则允许发送；
- 设置了 TCP_NODELAY 选项，则允许发送；
- 未设置 TCP_CORK 选项时，若所有发出去的小数据包（包长度小于 MSS）均被确认，则允许发送；
- 上述条件都未满足，但发生了超时（一般为 200ms），则立即发送。

#### 49.2 延迟确认

如果接受方刚接收到发送方的数据包，在很短很短的时间内，又接收到第二个包。那么请问接收方是一个一个地回复好点，还是合在一起回复好呢？

接收方收到数据包后，如果暂时没有数据要发给对端，它可以等一小段时间，再确认（Linux 上默认是 40ms）。如果这段时间刚好有数据要传给对端，ACK 就随着数据传输，而不需要单独发送一次 ACK。如果超过时间还没有数据要发送，也发送 ACK，避免对端以为丢包。

但是有些场景不能用延迟确认，比如发现了**乱序包**、**接收到了大于一个 frame 的报文，且需要调整窗口大小**等。

一般情况下，**Nagle 算法和延迟确认**不能一起使用，Nagle 算法意味着延迟发，**延迟确认**意味着延迟接收，酱紫就会造成更大的延迟，会产生性能问题。

### 50. TCP 的重传机制

**思路讲解：**  TCP 的重传机制，也是道非常高频的面试题。重传包括**超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种**。

#### 50.1 超时重传

超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。

这个一定时间内，一般是多少比较合理呢？来看下什么叫**RTT（Round-Trip Time，往返时间）**。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344518852-cec72539-b6c1-469a-b878-ef9aca204549.png)

RTT 就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。超时重传时间，就是 RTO（Retransmission Timeout)。

那么，**RTO 到底设置多大呢？**

- 如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。
- 如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。

一般来说，RTO 略微大于 RTT，效果是最佳的。其实，RTO 有个标准方法的计算公式，也叫**Jacobson / Karels 算法**。一起来看下吧：

**1. 首先计算 SRTT（即计算平滑的 RTT）**

```
SRTT = (1 - α) * SRTT + α * RTT // 求 SRTT 的加权平均
```

**2. 其次，计算 RTTVAR (round-trip time variation)**

```
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) // 计算 SRTT 与真实值的差距
```

**3. 最后，得出最终的 RTO**

```
RTO = µ * SRTT + ∂ * RTTVAR = SRTT + 4·RTTVAR
```

一般情况，α、β等的参数取值如下：

```
α = 0.125，β = 0.25， μ = 1，∂ = 4
```

别问这些参数是怎么来的，它们是大量实践，调出的最优参数。

超时重传不是十分完美的重传方案，它有这些缺点：

- 当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。
- 当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。

并且，对于 TCP，如果发生一次超时重传，时间间隔下次就会加倍。

**总结：**

超时重传：若一个已经发送的报文段在超时时间内没有收到确认，就重传这个报文段。超时时间RTO略大于加权往返时间RTTs。往返时间RTT指一个报文段从发送再到接收到确认所经过的时间。

#### 50.2 快速重传

其实可以使用**快速重传**，来解决超时重发的时间等待问题。它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。快速重传流程如下：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344519887-1ddf016f-b325-4639-9807-5517af398a1b.png)

快速重传流程

发送方发送了 1，2，3，4，5,6 份数据:

- 第一份 Seq=1 先送到了，于是就 Ack 回 2；
- 第二份 Seq=2 也送到了，于是 ACK 回 3；
- 第三份 Seq=3 由于网络等某些原因，没送到；
- 第四份 Seq=4 送到了，但是由于 Seq=3 没收到。因此 ACK 还是回 3；
- 后面的 Seq=5,6 的也送到了，ACK 还是回复 3，因为 Seq=3 没有收到。
- 发送方连着收到三个重复冗余 ACK=3 的确认（其实是 4 个哈，但是因为前面的一个是正常的 ACK，后面三个才是重复冗余的），于是知道哪个报文段在传输过程中丢失了；发送方在定时器过期之前，重传该报文段。
- 最后，接收方收到了 Seq=3，此时因为 Seq=4，5，6 都收到了，于是它回 ACK=7。

但是呢，**快速重传**也可能有问题：ACK 只向告知发送方，最大的有序报文段。到底是哪个报文丢失了呢？**并不确定**！那到底该重传多少个包呢？

是重传 Seq=3 ？还是重传 Seq=3、Seq=4、Seq=5、Seq=6 呢？因为发送端并不清楚这三个连续的 ACK=3 是谁传回来的。


#### 50.3 带选择确认的重传（SACK）

为了解决：**应该重传多少个包**的问题? TCP 提供了**带选择确认的重传**（即 SACK，Selective Acknowledgment）。

 **SACK 机制**就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包啦。

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344519932-ac881311-6d06-481f-b859-9d0f4585983e.png)

SACK 机制

如上图中，发送方收到了三次同样的 ACK=30 的确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有`30~39`这段数据丢失，于是重发时，就只选择了这个`30~39`的 TCP 报文段进行重发。

#### 50.4 重复 SACK（D-SACK）
D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。来看个图吧：

![img](https://cdn.nlark.com/yuque/0/2022/png/22219483/1648344520782-02000f91-8b60-4adf-a446-9366910f9838.png)

D-SACK 简要流程

### 51. UDP首部

UDP的首部只有8个字节，源端口号、目的端口号、长度和校验和各两个字节

![img](https://cdn.nlark.com/yuque/0/2021/png/450565/1635828808766-215845b3-f6ae-49ee-ab42-e7a6e29eaff3.png)


### 52. 负载均衡算法有哪些？

多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。

- 轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。
- 随机法：随机获取一台，和轮询类似。
- 哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。
- 加权轮询：根据服务器性能不同加权。



1. jwt

1. 1.  使用流程
   2. access token过期怎么去找到对应的 refresh token
   3. 为什么要用两个，而不用一个token
   4. refresh token的作用
   5. 直接给你两周的access token 为什么还要设计refresh token
   6. 额外设计refresh token的意义是什么
   8. 整个后期数据传输的加密的密钥都是客户端生成的吗？

4. 什么情况下会发生快速重传？

1. 1. **错误码可以自定义吗？**

1. 1. 1. 常见自定义错误码

- - 暂定都是5位数字
  - 0标识成功,其他都表示错误
  - 错误码按模块按功能场景分级分段
- - - 前三位表示模块
    - 第四位表示模块下的功能
- - 示例:
- - - 商城系统里有交易模块和商品模块
- - - - 401开头的表示交易模块
- - - - - 4011开头的表示交易模块里的下单场景需要用到的错误码
- - - - 402开头的表示商品模块
- - - - - 4021表示商品模块下的添加商品场景里需要用到的错误码
- - - - 如果某个场景功能下需要的比较多的错误码，则可以使用其他未被使用的码段，即该场景功能可以拥有多个码段，然后通过添加注释等方式让人理解即可。
- - 数字 1 开头的错误码表示
- - - 系统级别的错误
- - - - 缺少某种字符集，连不上数据库之类的，系统级的错误码不需要分模块，可以按照自增方式进行添加
- - 数字 4 开头的错误码表示
 - - - API参数校验失败
 - - - - “交易模块下单场景中，订单金额参数不能为空” 可以用 40111 错误码来表示
 - - 数字 5 开头的错误码表示
 - - - 后台业务校验失败
 - - - - “交易模块下单场景中，该用户没有下单权限” 可以用 50111 错误码来表示
 - - 注意
 - - - 数字 4 开头的错误码与数字 5 开头的错误码对应的模块分类需要保持一致，即 4011 表示交易模块下单场景的API错误，5011 表示交易模块下单场景的业务错误错误码按需分配，逐步增加，灵活扩展

